---
globs: apps/api/*
alwaysApply: false
---

## ğŸ—ï¸ Architecture

### Module-Based Structure

```
src/modules/
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ auth.dto.ts       # Schemas and types
â”‚   â”œâ”€â”€ auth.route.ts     # Route definitions
â”‚   â””â”€â”€ auth.guard.ts     # Middleware
â”œâ”€â”€ media/
â”‚   â”œâ”€â”€ media.dto.ts
â”‚   â”œâ”€â”€ media.route.ts
â”‚   â””â”€â”€ media.service.ts
â””â”€â”€ torrent/
    â”œâ”€â”€ torrent.dto.ts
    â”œâ”€â”€ torrent.route.ts
    â”œâ”€â”€ torrent.service.ts
    â””â”€â”€ torrent-download.service.ts
```

- Each module contains related routes, services, and DTOs
- Keep business logic in service classes
- Use guards for authentication/authorization
- Share utilities in `src/helpers/`

### DTO Pattern

Each module **must** have a `{module}.dto.ts` file containing:

- **Zod schemas** for validation (request/response)
- **TypeScript types** inferred from schemas
- **Database types** using drizzle-zod's `createSelectSchema` and `createInsertSchema`

#### Database Types

For database entities, use Drizzle-Zod to generate schemas:

```typescript
import { createSelectSchema, createInsertSchema } from "drizzle-zod";
import { user } from "@/db/schema";

// Database schemas
export const userSelectSchema = createSelectSchema(user);
export const userInsertSchema = createInsertSchema(user);

// Exported types
export type User = Omit<typeof userSelectSchema._output, "password">;
export type NewUser = typeof userInsertSchema._input;
```

#### Non-Database Types

For types that don't come from the database (e.g., API responses from external services):

```typescript
import { z } from "zod";

// Define Zod schema first
export const torrentSchema = z.object({
  title: z.string(),
  tracker: z.string(),
  size: z.number(),
  seeders: z.number(),
  // ... other fields
});

// Infer TypeScript type
export type Torrent = z.infer<typeof torrentSchema>;
```

### Type Exports

- **`schema.ts`**: Only export table definitions and enums (e.g., `IndexerType`, `UserRole`)
- **`{module}.dto.ts`**: Export all types and schemas for the module
- **`types.ts`**: Re-export only TypeScript types (not Zod schemas) for frontend consumption

### Service Pattern

- Extend `AuthenticatedService` for services needing database/user access
- Use dependency injection via context
- Keep services focused on business logic
- Handle errors appropriately
- Import types from DTOs, not from schema
- **Always add explicit return types to all service methods**

Example:

```typescript
import { AuthenticatedService } from "@/classes/authenticated-service";
import type { Media } from "./media.dto";
import type { Paginate, PaginationParams } from "@/modules/pagination";

export class MediaService extends AuthenticatedService {
  async getMediaById(id: number): Promise<Media | null> {
    return await this.db.select().from(media).where(eq(media.id, id)).get();
  }

  async getAll(
    type: Media["type"],
    { page, limit, offset }: PaginationParams
  ): Promise<Paginate<Media>> {
    const results = await this.db
      .select()
      .from(media)
      .where(eq(media.type, type))
      .limit(limit + 1)
      .offset(offset);
    return toPaginate(results, page, limit);
  }
}
```

## ğŸ›£ï¸ Hono Framework

### Route Definition

```typescript
import { zValidator } from "@hono/zod-validator";
import { Hono } from "hono";

import { authGuard } from "@/modules/auth/auth.guard";
import { paginationParams } from "@/modules/pagination/pagination.helper";
import type { HonoVariables } from "@/types/hono";
import {
  listMediaSchema,
  mediaInsertSchema,
  mediaSelectSchema,
  mediaUpdateSchema,
} from "./media.dto";
import { MediaService } from "./media.service";

export const mediaRoutes = new Hono<{ Variables: HonoVariables }>()
  .use("*", authGuard)
  .get("/", zValidator("query", listMediaSchema), async (c) => {
    return c.json(
      await MediaService.fromContext(c).list(
        c.req.valid("query"),
        paginationParams(c)
      )
    );
  })
  .get("/:id", async (c) => {
    return c.json(
      await MediaService.fromContext(c).get(Number(c.req.param("id")))
    );
  })
  .post("/", zValidator("json", mediaInsertSchema), async (c) => {
    return c.json(
      await MediaService.fromContext(c).upsert(c.req.valid("json"))
    );
  })
  .patch("/:id", zValidator("json", mediaUpdateSchema), async (c) => {
    return c.json(
      await MediaService.fromContext(c).update(
        Number(c.req.param("id")),
        c.req.valid("json")
      )
    );
  })
  .post("/like", zValidator("json", mediaSelectSchema), async (c) => {
    return c.json(
      await MediaService.fromContext(c).toggleLike(c.req.valid("json"))
    );
  })
  .post("/watch-list", zValidator("json", mediaSelectSchema), async (c) => {
    return c.json(
      await MediaService.fromContext(c).toggleWatchList(c.req.valid("json"))
    );
  });

export type MediaRoutesType = typeof mediaRoutes;
```

### Route Conventions

- Use RESTful conventions:
  - `GET /resource` - List resources
  - `GET /resource/:id` - Get single resource
  - `POST /resource` - Create resource
  - `PATCH /resource/:id` - Update resource
  - `DELETE /resource/:id` - Delete resource
- Group related routes in modules
- Apply middleware at appropriate levels
- Return appropriate HTTP status codes

### Validation

- **Always use `zValidator`** for query params, body, and params
- **Define validators as constants** when reused across routes (e.g., `mediaTypeValidator`)
- **Use existing enums** from `schema.ts` - never redefine them
- Access validated data with `c.req.valid("query")`, `c.req.valid("json")`, or `c.req.valid("param")`

Example:

```typescript
import { z } from "zod";
import { mediaTypeEnum } from "@/db/schema";

// Reusable validator
const mediaTypeValidator = z.object({ type: z.enum(mediaTypeEnum) });

export const routes = new Hono().get(
  "/",
  zValidator("query", mediaTypeValidator),
  async (c) => {
    const { type } = c.req.valid("query"); // Validated and typed
    // ...
  }
);
```

### Pagination

Use the centralized pagination module for consistent paginated responses:

```typescript
import { paginationParams, toPaginate } from "@/modules/pagination";
import type { Paginate, PaginationParams } from "@/modules/pagination";

// In routes - parse pagination from query params
.get("/", async (c) => {
  const pagination = paginationParams(c); // { page, limit, offset }
  return c.json(await Service.fromContext(c).getAll(pagination));
});

// In services - use PaginationParams type and toPaginate helper
async getAll({ page, limit, offset }: PaginationParams): Promise<Paginate<Media>> {
  const results = await db.select().from(media).limit(limit + 1).offset(offset);
  return toPaginate(results, page, limit); // { results, page, hasMore }
}
```

**Pagination Module:**

- `paginationParams(c)`: Extracts `page`, `limit`, and `offset` from query params
- `toPaginate(items, page, limit)`: Formats results into `Paginate<T>` with `hasMore` flag
- `PaginationParams`: Type for `{ page, limit, offset }`
- `Paginate<T>`: Type for `{ results: T[], page, hasMore }`

### Middleware

- **authGuard**: Require authentication
- **requireRole**: Check user role
- Use middleware for cross-cutting concerns
- Order matters - apply in correct sequence

## ğŸ” Authentication & Authorization

### Session Management

- Use cookie-based sessions
- Set `httpOnly`, `secure`, `sameSite` flags
- Implement session expiration
- Clean up expired sessions

### Role-Based Access Control (RBAC)

- Roles: `viewer`, `member`, `admin`, `owner`
- `viewer`: Read-only access
- `member`: Can download torrents
- `admin`: User management
- `owner`: Full access

```typescript
// In routes
.use("/download/*", requireRole("member"))

// In services
if (!["admin", "owner"].includes(user.role)) {
  throw new Error("Unauthorized");
}
```

## ğŸ—„ï¸ Database (Drizzle ORM)

### Migrations

- Generate migrations: `pnpm db:generate`
- Apply migrations: `pnpm db:migrate`
- Push schema (dev): `pnpm db:push`
- Never edit migration files manually
- Test migrations before deploying

### Best Practices

- Use transactions for related operations
- Implement proper indexes for frequently queried columns
- Use prepared statements (Drizzle does this automatically)
- Implement soft deletes where appropriate
- Use foreign keys for referential integrity

## ğŸ“¦ Dependencies

### Core Dependencies

- **hono**: Web framework
- **drizzle-orm**: Database ORM
- **zod**: Schema validation
- **webtorrent**: Torrent client
- **ms**: Time utilities

### Adding Dependencies

- Check package size
- Verify TypeScript support
- Check maintenance status
- Review security vulnerabilities

## ğŸ“‹ Checklist Before Commit

- [ ] Routes are properly typed
- [ ] Validation schemas are defined
- [ ] Authentication/authorization is implemented
- [ ] Error handling is proper
- [ ] No typescript error + Linting passes (`pnpm check`)
- [ ] Sensitive data is not exposed

## ğŸš¨ Common Pitfalls to Avoid

âŒ **DON'T:**

- Trust user input
- Use `any` type
- Recreate types or enums that already exist (use imports from `schema.ts`)
- Export types from `schema.ts` (only tables and enums)
- Define inline Zod schemas in route files (use constants or DTOs)
- Hardcode configuration values
- Use synchronous file operations
- Forget return types on service methods

âœ… **DO:**

- Define all schemas in DTO files or as constants in route files
- Use `createSelectSchema` and `createInsertSchema` for database types
- Infer TypeScript types from Zod schemas
- Export only TypeScript types in `types.ts` (not Zod schemas)
- Import types from DTOs in route and service files
- Import enums from `schema.ts` (e.g., `mediaTypeEnum`, `userRoleEnum`)
- Use `paginationParams(c)` helper for pagination
- Add explicit return types to all service methods
- Use `zValidator` for all input validation
